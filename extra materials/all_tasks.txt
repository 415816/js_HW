1.1
1. Открыть сайт: https://anatoly-karpovich.github.io/demo-login-form/
2. Составить чеклист проверок для сайта (названия проверок должны отражать и тестовые данные, которые будут вводиться)
3. Отобрать кейсы для автоматизации (приоритизировать и так далее)
4. Если найдутся баги - завести баг репорты
5. Оформить в эксель файле

Страница регистрации:
 - Username: обязательное, 
 - от 3 до 40 символов включительно,  - запрещены префиксные/постфиксные пробелы, как и имя состоящее из одних пробелов

Password: обязательное, 
 - от 8 до 20 символов включительно,  - необходима хотя бы одна буква в верхнем и нижнем регистрах, 
 - пароль из одних пробелов запрещен

Страница логина:
 - Username: обязательное
 - Password: обязательное

1.2
1. Открыть сайт:
https://anatoly-karpovich.github.io/demo-shopping-cart/

2. Найди промокод и ввести
3. Прислать скрин с полученной скидкой и местом где найден промокод


1. Инациализация
Link to git: http://git-scm.com/downloads

Для проверки, что Git установлен используйте в терминале команду:
git --version

Как только приложение Git установлено на комьютер, нужно идентифицровать себя, используя username и email address. 
К этому моменту уже необходимо иметь аккаунт созданный в гите

Обязательная инациализация пользователя:
git config --global user.name "Anatoly"
git config --global user.email "anatolykarpovich@email.com"

Для проверки:
git config --global --list

Также инициализировать можно вручную введя файлы в гит конфиг

=======================================================================================================================

2.1
1. Зайдите на github.com, зарегистрируйтесь, создайте public репозиторий  c названием Git_hw
2. Клонировать репозиторий Git_HW на локальный компьютер. (Команда git clone "repo")
3. Внутри локального Git_HW создать файл "new.txt".
4. Добавить файл под гит. (добавить содержимое рабочего каталога в индексб команда git add)
5. Закоммитить файл/сделать коммит
6. Отправить файл на внешний GitHub репозиторий.
7. Зайти на GitHub.com, проверить добавленный файл в удаленном репозитории
8. В локальном репозитории отредактировать содержание файла "new.txt" - написать информацию о себе (ФИО, возраст, количество домашних животных, будущая желаемая зарплата). Всё написать в формате txt.
9. Отправить изменения на внешний репозиторий. (посторить действия пунктов 4,5,6)
10. Создать файл preferences.txt
11. В файл preferences.txt" добавить информацию о своих предпочтениях в формате txt.
12. Создать файл sklls.txt добавить информацию о скиллах которые будут изучены на курсе в формате txt
13. Создать файл secrets.txt добавить туда ваш супер-секретный ключ (придумайте что угодно)
14. Добавить secrets.txt в gitignore (предварительно создать файл gitignore и разместить его в корне проекта) 
15. Отправить сразу 2 файла на внешний репозиторий. (повторить действия 4,5,6), Сделать коммит в одну строку.
16. На веб интерфейсе (github.com) создать файл bug_report.txt.
17. Сделать Commit changes (сохранить) изменения на веб интерфейсе.
18. На веб интерфейсе модифицировать файл bug_report.txt, добавить баг репорт в формате txt.
19. Сделать Commit changes (сохранить) изменения на веб интерфейсе.
20. Синхронизировать внешний и локальный репозиторий Git_HW
21. На локальном репозитории создать новую ветку "first_branch"
22. На локальном репозитории создать новую ветку "second_branch"
23. На ветке first_branch создать еще 1 файл с баг репортом (закоммитать+запушить)
24. На веб интерфейсе создать Pull Request c вашими изменениями на first_branch в main (гитхаб сам предложит, не пропустите!)
25. Вмержить pull request
26. На локальном перейти на ветку main
27. Стянуть свежие изменения и обновить main
28. Перейти на ветку second_branch
29. Вмержить main в second_branch
30. Запушить изменения на внешний репозиторий ветки second_branch
31. На ветке second_branch создать 3й багрепорт (сделать commit and push)
32. Перейти на ветку first_branch
33. Скопировать коммит из пунка 31 в first_branch нужной коммандой
34. Запушить изменения на внешний репозиторий ветки first_branch
35. Перейти в main
36. Сделать Rebase first_branch в main
37. Отправить изменения на внешний репозиторий

2.2
В вашем репозитории создайте следующее правило для защиты веток:

Запрещено мержить ветку (хотя бы в мастер), если в пулреквесте нету КАК МИНИМУМ ОДНОГО аппрува (не вашего!!). Можно запросить менторов и/или других студентов дать свой емейл чтобы подключить их к вашему репозиторию для "код ревью" и возможности апрувать код.

======================================================================================================================

3.1

Task 1. Работа с переменными:

1. Создать переменную “item_1”

2. Присвоить переменной item_1 цифру 5.

3. Вывести в консоль item_1.

4. Создать переменную “item_2”

5. Присвоить переменной item_2 цифру 3.

6. Вывести в консоль item_2.

7. Создать переменную “item_3”

8. Присвоить переменной item_3 сложение item_1 и item_2.

9. Вывести в консоль item_3.

10. Создать переменную “item_4”

11. Присвоить переменной item_4 строку “Yolochka”

12. Вывести в консоль item_4.

13. Вывести в консоль сложение item_3 и item_4.

14. Вывести в консоль умножение item_3 и item_4.

15. Создать переменную “item_5”

16. Присвоить переменной item_5 переменную item_3

17. Создать переменную item_6.

18. Создать переменную item_6_type

19. Присвоить переменной item_6 значение 15

20. Присвоить переменной item_6_type тип переменной item_6

21. Вывести в консоль тип данных item_6 в виде ——  “item_6 == ”  item_6,  “item_6_type == ”  item_6_type ——  

22. Создать переменную item_7 и в ней преобразовать item_6 в String.

23. Создать переменную item_7_type

24. Присвоить переменной item_7_type тип переменной item_7

25. Вывести в консоль тип данных item_7 в виде ——  “item_7 == ”  item_7,  “item_7_type == ”  item_7_type ——  

3.2
Task2*. Решить квадратные уравнения. Переменные называть по правилам.
Вывести в консоль ответы в виде "Ответ к уравнению 1: <корень>", "Ответ к уравнению 2: <корень> и <корень>"
1.  x2 - 6x + 9 = 0. - один корень
2.  x2 - 4x - 5 = 0. - два корня

3.3
Task3**. Напишите программу, которая принимает целое положительное число n (одно любое число от 1 до 9), и выводит сумму равную 
n + nn + nnn, где n не перемножаются, а конкатенируются

==================================================================================================================

4.1
  1. Создать переменную "minAge" и присвоить ей значение 18
  2. Создать переменную "maxAge" и присвоить ей значение 60
  3. Создать переменную "age", в которую вы будете вводить возраст при выполнении программы
  4. Создать if в котором будете проверять весь код переменной age со следующими условиями:
    - Если age меньше чем minAge, вывести в консоль "You don't have access cause your age is " + "age" + " It's less then "
    - Если "age" больше либо равно  minAge и меньше  maxAge, вывести в консоль "Welcome  !"
    - Если "age" больше maxAge, вывести в консоль "Keep calm and look Culture channel".
    - Иначе выводите "Technical work".
  5. Проверить задание со следующими значениями в переменной age: 10, 17, 18, 19, 59, 60, 61

4.2
1.
Реализовать Task 1 через switch

2. 
Преобразовать написанный код в task 1 так, чтобы сначала проверялся тип данных. 
  И если он не number - кидалась ошибка в консоль.
  Проверить работу кода на следующих данных 17, 18, 61, "2", "aaa"

3.
Преобразовать Task 2 - 2 таким образом, чтобы значение НАПРИМЕР '2' (т.е. ЛЮБАЯ строка в которой лежат ТОЛЬКО ЦИФРЫ) пропускалось, 
  преобразовываясь в number


4.3
Преобразовать Task 2* таким образом, чтобы age принимался через prompt в привязанной вёрстке, а результат выводился в alert

=====================================================================================================================

5.1

1. Создайте цикл, который выведет в консоль цифры от 10 до 0
2. Написать скрипт, который выведет 5 строк в консоль таким образом, чтобы в первой строчке выводилось :), во второй :):) и так далее
  Пример в консоли:
  :)
  :):)
  :):):)
  :):):):)
  :):):):):)

  Для Оксаны и ее друзей: также реализовать циклом while
  Рекоммендация: попробуйте метод .repeat()

5.2
1. Написать скрипт, переводящий количество байт в нужные единицы
  bytes => kB Mb Gb Tb
  16 565 846 bytes (16,6 Mb)

  1 Kb = 1024 byte
  1 Mb = 1024 Kb
  1 Gb = 1024 Mb
  1 Tb = 1024 Gb

  // Пример: ~ 1000
  4 548 = 4,5 Kb (Real 4,4 Kb)
  454 548 = 454,5 Kb
  1 454 548 = 1,5 Mb

  Результат должен быть округлен до 1 знака после запятой методом .toFixed(), про который надо почитать самим ;)

2. Сделать из "*" в консоли равнобедренный треугольник и ромб

3.  Вам нужно вывести в консоль числа от 1 до 100.
    Если число делится без остатка на 3, то выведете в консоль “число - делится на 3”.
    Если число делится на 5 без остатка, то то выведете в консоль “число - делится на 5”.
    Если число делится и на 3 и на 5 без остатка, то то выведете в консоль “число - делится и на 3 на 5”.
    Число 15 делится без остатка на 3 и на 5 -- пример сообщения в консоле.

4. Написать скрипт, который преобразует любое предложение в camelCase. Первое слово должно начинаться с буквы в нижнем регистре, 
  у остальных -  верхнем. Пример: I am super engineer => iAmSuperEngineer

5.3
1*. Создать программу, которая будет принимать на вход СЛОВО (создать переменную со словом), 
  и выводить в консоль количество гласных и согласных букв в этом слове. 
  Ответ должен выводиться шаблонным литералом вида word contains x vowels and y consonants

2**. Написать программу, которая видоизменяет принимаемое слово (переменная со словом) 
  шифром ЦЕЗАРЯ (посмотреть в википедии) со сдвигом на 1 в любую из сторон. 
  Направление шифрования задается переменной offset, которая может быть +1 и -1.
  Например let str = 'AbC'; let offset = -1, result = 'ZaB';
  Например let str = 'ZzZ'; let offset = 1, result = 'AaA';

====================================================================================================================

6.1
1. Создайте функцию getEmployeeInfo()
2. В функции создайте массив имен сотрудников 5шт (Имена придумать самим)
3. В функции создайте массив зарплат сотрудников 5 шт(цифры придумать самим)
4. Функция должна принимать 1 аргумент - имя сотрудника
5. Функция должна возвращать новый массив, где первый элемент - имя сотрудника, второй - его зарплата
6. Для поиска ответа функции нужно найти индекс сотрудника в массиве имен. Зарплату взять с ТЕМ ЖЕ индексом что и имя
7. Для возврата из функции создайте массив, методом .push поместите в него имя и зарплату, и через return верните созданный массив
8. Если такое имя сотрудника в массиве не найдется - вернуть null

6.2
1. У вас есть массив названий пицц вашего конкурента. Создайте функцию, которая будет принимать ваш набор названий пицц (массив) 
  и возвращать только те, которых нет у конкурента (тоже массив). Если все ваши пиццы есть у конкурента - вернуть null
  Пиццы конкурента:
  const competitorPizzas = ['Peperoni', 'Caprichosa', 'Diablo', '4 cheeses', 'hawai']
  
2. Написать функцию, которая принимает предложение (слова разделенные только пробелами) в качестве параметра и выводит в консоль слово с наибольшим количеством букв. 
  Если таких слов несколько - выводит их все.

3. Напишите функцию, которая принимает на вход массив чисел, убирает из него дубликаты и возвращает массив с только уникальными значениями.

4. Написать функцию, которая принимает на вход слово и проверяет, является ли это слово палиндромом

6.3
5*. Напишите рекурсивную функцию, которая принимает на вход число и складывает его цифры. 
  Если сумма получилась больше 9 - снова сложите цифры. И так пока, сумма не станет меньше либо равной 9. 
  После окончания сложений возвращает полученное число. Например при подаче числа 19 (1+9=10>9, потому 1+0=1) выводится 1

6*. Написать функцию, которая принимает на вход строку с текстом, и заменяет каждую пару стоящих подряд идентичных букв на одну следующую в алфавите, 
    и так пока в тексте не останется двух одинаковых букв стоящих рядом (через пробел и другой знак препинания можно)
    Пример: aabc => bbc => cc => d

=======================================================================================================================

7.1
1. Создайте функцию getOnlyNumbers, принимающую на вход массив arrayOnAnyValues
2. Внутри функции создайте переменную result, в которую упадет результат работы метода .filter()
3. В метод filter передайте callback функцию, проверяющую является ли значение числом.
4. В переменной result должны остаться только те элементы массива arrayOnAnyValues, которые являются числами ('2' - не число)
5. Вернуть result из функции

6. Проверить с массивом const arr = [NaN, 1, true, 5, "hello", undefined, 15.5, {}, []];

7.2
1. На вход функции подаётся предложение, например “I am the best AQA ever!” Преобразуйте строку таким образом, 
  чтобы вместо каждой буквы была цифра, показывающая сколько раз эта буква встречается в предложении. 
  Пробелы и знаки препинания оставляем без изменения. Регистр не должен играть роли.

2. У вас есть массив с ценами товаров в чеке. В консоль нужно вывести сумму всех цен и среднюю цену товара.
  Итого: 8495 $, средняя цена товара 700 $ - пример сообщения в консоле.  
  const prices = [64, 7556, 345, 7556, 345, 7556, 345, 7556, 433, 345, 756, 123, 942, 3112, 421, 9341, 1212, 8, 43, 41, 345, 341, 21, 321, 123];

3. Напишите функцию, которая принимает на вход массив слов и возвращает отсортированный массив по по следующему критерию: количество гласных букв.
  Массив должен быть отсортирован по возврастанию количества гласных букв в слове.

4. У вас есть массив со скобками, предположим [ ‘(‘, ‘)’, ‘(‘, ‘)’, ‘)’], количество элементов и последовательность может быть разной.
  Нужно выяснить, у каждой ли скобки есть соответствующая пара (открывающая и закрывающая).
  Усложнение: в массиве могут быть вложены еще массивы на разной глубине. (ПОПРОБУЙТЕ МЕТОД .flat(), изучите как он работает с разными глубинами вложенности)
  Вернуть нужно всё также есть ли у каждой скобочки соответствующая пара. 
  Пример:
  const arr = [[['(']], ')', '(', ')', ')', ['(', ['('], [')']]]

7.3
5*. Напишите функцию findMissingNumber(arr), которая принимает массив чисел от 1 до N (исключая одно число) 
  и возвращает пропущенное число. Массив не отсортирован и может содержать дубликаты. 
  Решите эту задачу, используя эффективные методы массива.

6**. В файле вы найдете массив карточек юзеров. Задача - создать функцию, которая уберет из массива дубликаты. 
  Вернуть массив с сугубо уникальными карточками. Реализовать методом SET. 
  Разобраться, как считать данные из файла КОДОМ, а не копировать ручками.

=================================================================================================================

8.1
Task 1.
Имеется массив объектов (ниже). Ваше задание:
1. Используя Object.keys и метод forEach вывести в консоль ключи каждого объекта
2. Используя Object.values и метод forEach вывести в консоль значения каждого объекта
3. Перебрать форычем массив. На каждой итерации вывести пары ключ-значнение в виде `key = ${ket}, value = ${value}`.
   Перебирать каждый объект циклом for..of вида for(const [key, value] of Object.entries)
4. Перебрать форычем массив. На каждой итерации вывести пары ключ-значнение в виде `key = ${key}, value = ${value}`.
   Перебирать каждый объект циклом for..in
5. Создайте объект qa с полями name, age, salary и методом getInfo, который будет возвращать строку вида: 
   `Hello, my name is ${name}, i'm ${age} and my salary is ${salary}`. Значения в строке должны ссылаться на контекст ЭТОГО ОБЪЕКТА, без подмен.

 const characters = [
    { 'name': 'Barney', 'age': 36 },
    { 'name': 'Fred', 'age': 40 },
    { 'name': 'Jack', 'age': 50 }
  ];

8.2
Task 2. Перед вами структура компани, и ниже представлены задания, относящиеся к ней. 
В заданиях по максимуму использовать методы массивов, создавать функции-помощники, выполняющие дополнительные действия,
чтобы ваши функции выполняли строго одну работу. ЭТО ОЧЕНЬ ВАЖНО!

const enterprises = [
  {
    id: 1,
    name: "Предприятие 1",
    departments: [
      {
        id: 2,
        name: "Отдел тестирования",
        employees_count: 10,
      },
      {
        id: 3,
        name: "Отдел маркетинга",
        employees_count: 20,
      },
      {
        id: 4,
        name: "Администрация",
        employees_count: 15,
      },
    ]
  },
  {
    id: 5,
    name: "Предприятие 2",
    departments: [
      {
        id: 6,
        name: "Отдел разработки",
        employees_count: 50,
      },
      {
        id: 7,
        name: "Отдел маркетинга",
        employees_count: 20,
      },
      {
        id: 8,
        name: "Отдел охраны труда",
        employees_count: 5,
      },
    ]
  },
  {
    id: 9,
    name: "Предприятие 3",
    departments: [
      {
        id: 10,
        name: "Отдел аналитики",
        employees_count: 0,
      },
    ]
  }
]

Задания:
1. Вывести все предприятия и их отделы. Рядом указать количество сотрудников. Для предприятия посчитать сумму всех сотрудников во всех отделах.

**Пример:**

Предприятие 1 (45 сотрудников)
- Отдел тестирования (10 сотрудников)
- Отдел маркетинга (20 сотрудников)
- Администрация (15 человек)
Предприятие 2 (75 сотрудников)
- Отдел разработки (50 сотрудников)
- Отдел маркетинга (20 сотрудников)
- Отдел охраны труда (5 сотрудников)
Предприятие 3 (нет сотрудников)
- Отдел аналитики (нет сотрудников)

2. Написать функцию, которая будет принимать 1 аргумент (id отдела или название отдела и возвращать название предприятия, к которому относится).

Пример:
getEnterpriseName(4) // Предприятие 1
getEnterpriseName("Отдел маркетинга") // Предприятие 2

3. Написать функцию, которая будет добавлять предприятие. В качестве аргумента принимает название предприятия

Пример:
addEnterprise("Название нового предприятия")

4. Написать функцию, которая будет добавлять отдел в предприятие. В качестве аргумента принимает id предприятия, в которое будет добавлен отдел и название отдела.

Пример:
addDepartment(1, "Название нового отдела")

5. Написать функцию для редактирования названия предприятия. Принимает в качестве аргумента id предприятия и новое имя предприятия.

Пример:
editEnterprise(1, "Новое название предприятия")


6. Написать функцию для редактирования названия отдела. Принимает в качестве аргумента id отдела и новое имя отдела.

Пример:
editDepartment(7, "Новое название отдела")


7. Написать функцию для удаления предприятия. В качестве аргумента принимает id предприятия.

Пример:
deleteEnterprise(1)


8. Написать функцию для удаления отдела. В качестве аргумента принимает id отдела. Удалить отдел можно только, если в нем нет сотрудников.

Пример:
deleteDepartment(3)


9. Написать функцию для переноса сотрудников между отделами одного предприятия. В качестве аргумента принимает два значения: id отдела, из которого будут переноситься сотрудники и id отдела, в который будут переноситься сотрудники).

Пример:
moveEmployees(2, 3)

8.3
Ниже найдете разноуровневый массив объектов company, очень похожий на массив из прошлого задания, 
  только количество вложенностей может быть не ограничено. 
  Задание: написать функцию: 
  Функция строит древовидный список компании.
  При ее вызове в консоль должен вывестись список подразделений компании с указанием количества сотрудников и с 
  соблюдением вложенности подразделений.

const company = [
  {
    id: 1,
    name: "Компания",
    parent: null,
    users_count: 10,
    children: [
      {
        id: 2,
        name: "Отдел тестирования",
        parent: 1,
        users_count: 7,
        children: [
          {
            id: 2,
            name: "Тестирование Web",
            parent: 2,
            users_count: 5,
          },
          {
            id: 3,
            name: "Тестирование Mobile",
            parent: 2,
            users_count: 0,
          },
        ],
      },
      {
        id: 4,
        name: "Отдел маркетинга",
        parent: 1,
        users_count: 30,
      },
      {
        id: 5,
        name: "Администрация",
        parent: 1,
        users_count: 25,
        children: [
          {
            id: 6,
            name: "Бухгалтерия",
            parent: 5,
            users_count: 10,
          },
          {
            id: 7,
            name: "Менеджмент",
            parent: 5,
            users_count: 15,
            children: [
              {
                id: 8,
                name: "Подраздел менеджмента 1",
                parent: 7,
                users_count: 5,
              },
              {
                id: 9,
                name: "Подраздел менеджмента 2",
                parent: 7,
                users_count: 10,
              },
            ],
          },
          {
            id: 10,
            name: "HR",
            parent: 5,
            users_count: 1,
          },
        ],
      },
    ],
  },
];

===========================================================================================================

9.1 
Task 1

1. Создайте класс Animal
2. В конструкторе класс должен принимать следующие параметры:     
  - type
  - color
  - weight
  - height
  - place of origin
3. Добавьте в класс метод: getInfo, который возвращает в строке полную информацию о животном (используйте шаблонные строки с `${}` синтаксисом)
4. Создайте геттер для поля color (get color), не забывая что при этом поле должно быть _color
5. Создайте сеттер для поля color (set color(newColor)). В сеттере проверяйте, является ли цвет одним из следующих:
  - Красный
  - Черный
  - Белый
  - Синий
Если не является - кидаем ошибку через throw new Error('текст ошибки')
6. Создайте класс Snake, который будет наследовать класс Animal
7. Создайте конструктор в классе Snake, который будет принимать все необходимые поля из класса Animal, а также поле isPoisonous
8. С помощью super() вызовите конструктор родителя, передав необходимые параметры
9. В классе Snake создать метод checkPoisonous(), который возвращает true/false
10. Сделайте поле isPoisonous приватным в классе Snake


9.2
Task 2.
1. Создайте класс Bird с приватным полем isFlying, отнаследовавшись от Animal
2. Создайте класс CatLike с публичным полем isSafeToPet, отнаследовавшись от Animal
3. Создайте класс Worker, реализующий следующий интерфейс (набор полей и методов):
    class Worker
      firstName
      lastName
      phone
      getFullName()
4. Создайте класс Zoo, реализующий следующий интерфейс:
    class Zoo
      address
      title
      ticket price
      workers: []
      animals: [],
5. Добавьте геттеры и сеттеры к полям address, title, ticket price
6. Добавьте метод addWorker(worker), добавляющий работника в массив workers. 
    На вход метод должен принимать объект класса Worker. 
    Если объект не является инстансом класса Worker - выкинуть ошибку
7. Добавьте метод addAnimal(animal), добавляющий животное в массив animals.
    На вход метод должен принимать объект класса Animal, как и любого из его наследников. 
    Если объект не является инстансом класса Animal - выкинуть ошибку
    ТАКЖЕ, если объект является инстансом класса Snake - выкинуть ошибку с тексом "There will be no snakes, mister Potter!"
8. Добавьте методы removeWorker() и removeAnimal() // Подумайте, как будем удалять, по какому полю будем выбирать:)


9.3
Task 3:

2.  Вам необходимо команду айтишников для проекта!
    Вам нужно создать класс Team, структура представлена ниже. 
    Вы должны реализовать следующие методы:
      get/set team's name
      get/set team’s sprint duration (number of weeks)
      get planned release date
      get/set daily standup time
      get number of teammates
      add/remove/edit teammate
      add/remove/edit tasks (таски могут храниться только уникальные)
      show all teammates
      show teammates by specialication
      show all tasks

    Создайте класс ITSpecialist. Реализуйте следующие методы:
      get all info
      set country
      get salary
    Создайте дочерние классы для некоторых айтишников. 
    Реализовать возможность задавать свойства дочерних классов.
    Каждый класс должен находиться в своем собственном файле. 

    Структура:

    class Team
    name
    sprint_duration
    release_date
    daily_standup_time
    teammates: []
    tasks: [],

    class ITSpecialist
    name
    grade
    experience_in_years
    age
    country
    _salary

    class Manager
    isScrumMaster

    class QA
    isAqa

    class Developer
    isWritingUnitTests

    class Task
    featureName
    userStoryNumber
    estimations

================================================================================================================

10.1
1. Создайте таймаут (setTimeout), который выведет в консоль сообщение "After 2 seconds" через 2 секунды
2. Создайте новый промис, используя синтаксис new Promise((resolve, reject) => {//implementation}). 
    Промис должен резолвать слово success (использовать resolve)
    Получить слово success через .then и вывести в консоль внутри then
3. Создайте новый промис, используя синтаксис new Promise((resolve, reject) => {//implementation}). 
    Промис должен реджектать слово failed (использовать reject)
    Получить слово failed через .catch и вывести в консоль внутри catch
4. Добавьте к обработке промисов из 2 и 3 пункта блок finally, где выведите в консоль текст 'finally'
5. Создайте асинхронную функцию resolvePromise(promise)
  - Функция на вход принимает один аргумент, который должен быть промисом
  - В функции разместите блок try..catch..finally
  - В try получите результат работы промиса, вызвав его через await, а после результат выведите в консоль
  - В catch выведите в консоль сообщение 'Failed due to', а также ошибку, пришедшую из промиса (через шаблонные строки `${}`)
  - В finally выведите в консоль "Finished working with promise"
  - Воспроизведите функцию, передав в нее промисы из заданий 2 и 3 (на разных строках кода, не одновременно!)

10.2
1. Создайте функцию delay, принимающую на вход коллбэк функцию и количество милисекунд.
    Функция должна исполнить колбэк строго через переданное количество миллисекунд
    Пример: delay(() => console.log('hello'), 2000) // Через 2 секунды в консоли появится слово hello
    

2. Создайте два промиса:
  - promise1 должен резолвать "After 3 seconds" через 3 секунды
  - promise2 должен резолвать "After 5 seconds" через 5 секунд
  Резолвните оба промиса параллельно используя Promise.All и Promise.allSettled двумя способами:
    1. Обработайте результат Promise.All и Promise.allSettled в .then блоке. Выведите в консоль резолвы обоих промисов по очереди
    2. Обработайте результат await Promise.All и Promise.allSettled в асинхронной функции в try..catch блоке. 
        Используйте деструктуризацию, чтобы создать переменные promise1Result и promise2Result с резолвами соответствующих промисов
        Вывести в консоль результат обоих промисов по очереди

3. Напишите функцию, которая возвращает Promise, который резолвается в сумму двух чисел. 
  Функция должна принимать два аргумента (a и b) и возвращать Promise, который резолвает в a+b. 
  Если какой-либо из аргументов не является числом, Promise должен быть rejected с сообщением об ошибке. 
  Протестируйте свою функцию, вызвав ее с допустимыми и недопустимыми аргументами, 
  и обработайте любые ошибки с помощью метода .catch(), а также в блоке try/catch

4. С помощью fetch отправьте GET запрос на адрес "https://jsonplaceholder.typicode.com/todos". 
    Преобразуйте респонс в объект (.json()), выведите в консоль все объекты из респонса, где userId === 1. Решить с помощью try/cath и then (обоими способами)

10.3
1. На сайте JSONPlaceholder - Free Fake REST API  с помощью функции fetch получить список пользователей. 
  Вывести на экран: имя, e-mail, телефон и название компании пользователя.
  Отдельными запросами получить список альбомов пользователя и список фотографий в альбомах. 
  Дополнительно вывести список альбомов у пользователя с указанием количества в них фотографий. 
  Для реализации трех запросов воспользоваться Promise.all().
  (Принадлежность альбомов пользователем связано полем userId, принадлежность фотографий к альбомам сваязано полем albumId). 
      Пример: 
      1.  name: Leanne Graham
          email: Sincere@april.biz
          phone: 1-770-736-8031 x56442
          company: Romaguera-Crona    
          albums:
            Album name 1 (10 photos)
            Album name 2 (100 photos)
      __________________________________

      2.  name: Ervin Howell   
          email: Shanna@melissa.tv 
          phone: 010-692-6593 x09125
          company: Deckow-Crist
          albums:
            Album name 1 (10 photos)
            Album name 2 (100 photos)

2. Создайте конвертер валют, используя Exchange Rates API. (зарегистрироваться и получить токен) Данные с сайта брать запросом используя fetch(). 
  Пользователь должен иметь возможность передавать валюту и сумму денег в функцию и получать сумму денег в желаемой валюте на выходе. 
  Например: currencyConvertor(USD, 40, EUR) ⇒ 35 EUR
  Решить с помощью в 2 вариантах: с  .then() и с использованием async/await

https://exchangeratesapi.io/


=====================================================================================================================

11.1
1. Создайте interface ItEmployee
2. В интерфейсе ItEmployee сделайте поле name которое может быть только string
3. В интерфейсе ItEmployee сделайте поле surname которое может быть только string
4. В интерфейсе ItEmployee сделайте поле salary которое может быть только number и доступно только для чтения
5. Создайте тип данных Grade для стринговой переменной, которая может принимать значения: junior, middle, senior, lead
6. В интерфейсе ItEmployee сделайте поле grade типа Grade
7. Создайте enum OCCUPATION, который будет представлять професси в айти вида DEVELOPER = "Developer" и так далее
8. В интерфейсе ItEmployee сделайте поле occupation типа OCCUPATION
9. Создайте интерфейс IAddress, предствляющий объект с полями country, street, house, flat
10. В интерфейсе ItEmployee сделайте необязательное поле address типа IAddress
11. В интерфейсе ItEmployee сделайте projectNames, типа массив строк (названий проектов)
12. Создайте объект с типом ItEmployee

11.2
1. Создайте интерфейс IEmployee с полями name, surname, salary, address (типы для этих полей такие же как в ItEmployee из таск 1)
  Создайте функцию getEmployeeInfo(employee), выводящую в консоль всю информацию про employee (формат текста придумать самим)
  Создайте type guard isItEmployee, принимающий юнион типов IEmployee и ItEmployee. Используйте его в функции getEmployeeInfo. 
  Если на входе itEmployee - выводите в консоль все поля айтишника (а не только те, что в employee)
  Функция должна принимать union type между IEmployee и ItEmployee, и через тайпгвард определять что за объект и как работать с ним 

2. Создайте функцию, которая подсчитает, сколько в объекте значений каждого типа. 
  Принимает на вход объект или массив таких же объектов, у которого ключ всегда string, а значение - string, number, boolean. 
  Возвращает же - объект с ключами string, number, boolean и количеством таких значений в объекте или в сумме у всех объектов в массиве. 

3. Реализуйте функцию filter(), которая принимает на вход массив чисел и предикат (коллбэк), 
    который будет использоваться для проверки каждого числа на соответствие требованиям. 
    Помимо самой функции следует реализовать алиасы типов для функций и аттрибутов. 
    Пример функции:
    const numbers = [1, -5, 2, 3, 4, 133];
    filter(numbers, (n) => n > 3); // [4, 133]
    filter(numbers, (n) => n % 2 == 0); // [2, 4]
    Параметры функции: Массив чисел и Анонимная функция, принимающая на вход число и возвращающая логическое значение.

11.3
1. Создайте корзину в интернет магазине! 
    Создайте объект shoppingCart и его интерфейс!:
      items (array of products), each product should have:
        id (number)
        name (string)
        price (number)
        quantity (number)
    Добавьте методы к этому объекту:

    addItem(item) - Adds a new item to the cart.
    removeItem(id) - Removes an item from the cart by its id.
    getTotalPrice() - Returns the total price of the items in the cart.
    checkout() - Empties the cart and returns the total price.

    Пример:
    interface IShoppingCart { //implement }
    const cart: IShippingCart = {
    items: [
        { id: 1, name: "Laptop", price: 1000, quantity: 1 },
        { id: 2, name: "Phone", price: 500, quantity: 2 }
    ],
    addItem: function(item) {
        //implement
    },
    removeItem: function(id) {
        //implement
    },
    getTotalPrice: function() {
        //implement
    },
    checkout: function() {
        //implement
    }
};

=============================================================================================================

12.1
1. Создайте дженерик функцию getFirstElement, которая принимает массив элементов типа T, и возвращает первый элемент (типа T).

2. Создайте интерфейс Person, абстрактный класс Employee, который реализует интерфейс Person, и конкретные классы Manager и Developer.
  - Интерфейс Person должен содержать:
      Стринговые поля: name, surname, experienceYears
      Метод, возвращающий строку: getDetails().

  - Абстрактный класс Employee должен:
      Реализовывать интерфейс Person.
      Содержать защищенное поле: salary, не передающееся в конструктор (по дефолту 0)
      Содержать защищенный абстрактный метод: calculateSalary().,
        который считает зарплату и вызывается в конструкторе, и будет реализован в наследниках
  
  - Конкретные классы Manager и Developer должны:
      Наследоваться от Employee.
      Класс менеджер должен на конструкторе получать поле prefered, которое может быть только 'scrum' или 'kanban'
      Класс девелопер должен на конструкторе получать поле programmingLanguage, который может быть 'js', 'ts', 'java', 'python'
      Метод calculateSalary должен для менеджера устанавливать зарплату по формуле: количество лет опыта * 500
      Метод calculateSalary должен для девелопера устанавливать зарплату по формуле: количество лет опыта * 1000
      Реализовывать метод getDetails(), который должен выводить полную информацию об объекте вида:
        'My name is Elena TSovna, I am software developer with 6 years of experience in TypeScript and 6000$ salary' (пример для девелопера)

12.2
1. Напишите функцию, реализующую методы массивов map. Функции принимают на вход массив и колбэк. Используйте дженерик типы. 
   Затипизировать надо саму функцию и коллбэк.
   Создать реализацию функции map, принимающую массив чисел 1-5, возвращающую новый массив, 
   где каждый каждый элемент - это элемент исходного массива умноженный на его индекс
   Пример:
   map([1,2,3,4,5], callback) => [0,2,6,12,20]

2. Напишите дженерик функцию generateObject, которая принимает массив пар [string, T] 
  и возвращает объект, где каждая пара ключ-значение из массива превращается в соответствующую пару ключ-значение в объекте. 
  В случае если ключи повторяются, значение в объекте должно быть последним из встречающихся.

  Требования:
    - Функция должна быть дженерик и работать с любыми типами значений.
    - Функция должна корректно обрабатывать массив пар, включая случаи, когда ключи повторяются.

  Пример:
  const result = generateObject([
  ["1", 1],
  ["2", 2],
  ["3", 3],
  ["4", 4],
  ["4", 5], // повторяющийся ключ, значит это значение должно быть в результирующем объекте
]);

console.log(result); //{ '1': 1, '2': 2, '3': 3, '4': 5 }

12.3
Вам необходимо написать дженерик функцию processPromises, которая будет принимать массив функций, 
каждая из которых возвращает промис определенного типа, и режим выполнения (параллельный или последовательный). 
Функция processPromises должна выполнять эти промисы и возвращать массив результатов в соответствии с выбранным режимом выполнения.

Режимы выполнения:

"parallel": промисы должны выполняться параллельно с использованием Promise.all.
"sequence": промисы должны выполняться последовательно, ждать завершения каждого промиса перед выполнением следующего.

Массив функций: processPromises принимает массив функций без аргументов, возвращающих промисы. 
Эти функции должны быть типизированы как () => Promise<T>.
Для этого создайте функцию delay(value, timeout), которая будет возвращать резолв промиса с переданным value после истечения таймаута timeout

Возвращаемое значение: функция должна возвращать промис, который разрешается в массив результатов выполнения промисов.

Пример использования:
async function example(mode: "parallel" | "sequence") {
    const promise1 = () => delay("First", 1000);
    const promise2 = () => delay("Second", 500);
    const promise3 = () => delay("Third", 300);

  const results = await processPromises([promise1, promise2, promise3], mode);
  console.log(results); // Ожидаемый результат: ["First", "Second", "Third"]
}

example("sequence").catch((error) => console.error(error));
example("parallel").catch((error) => console.error(error));

=======================================================================================================================

13.1
1. Создайте интерфейс IEmployee {name: string, salary: number, isManager: boolean } и объект QA: IEmployee
2. Создайте тип EmployeeKeys, который будет юнионом названий ключей IEmployee (использовать keyof)
3. Создайте тип QaKeys, который будет содержать лишь ключи объекта QA(использовать keyof и typeof)
4. Создайте тип UserType из объекта QA (используйте typeof)
5. Создайте тип, в котором все поля интерфейса IEmployee будут необязательными
6. Создайте тип, который будет содержать поля name и salary из интерфейса IEmployee
7. Создайте тип, который будет держать все поля из интерфейса IEmployee, кроме isManager
8. Создайте тип, который будет содержать все поля из интерфейса IEmployee и сделает их неизменяемыми (readonly)
9. Создайте тип, для массива объектов, где в ключах могут быть строки, в значениях number, string или boolean

13.2
Создайте дженерик класс Storage<T>, где T должен быть ограничен объектом, имеющим КАК МИНИМУМ {id: number}.
Задача класса - хранить объекты типа Т в приватном массиве
Реализуйте в классе следующие методы:
  - constructor должен принимать необзятельный массив объектов соответствующего типа. 
    Если массив пришел - объекты запушить в хранилище.
  - add, принимающий либо объект типа Т, либо объект типа Т без id. Метод должен быть реализовать с помощью ПЕРЕГРУЗКИ.
    Если на вход подан объект без айди - айди надо сгенерировать, затем запушить обьект в хранилище
    Если на вход подан объект с айди - запушить его в хранилище
    Для типизации используйте Utility Types
  - update, принимающий объект с айди и любым набором остальных ключей из типа Т. 
  - remove, принимающий на вход id и удаляющий объект из массива
  - getById(id), возвращающий объект по айди если найден
  - getAll(), возвращает все объекты в хранилище

    storage.add({ id: 1, name: 'Anatoly', age: 33 }); // valid
    storage.add({ name: 'Elena', age: 25 }); // valid, created with id === 2

    storage.update({ id: 1, name: 'Egor' });
    storage.update({ id: 2, name: 'Tatiana', age: 33 });

    console.log(storage.getById(1)); // { id: 1, name: 'Egor', age: 33 }
    console.log(storage.getAll()); // [{ id: 1, name: 'Egor', age: 33 }, { id: 2, name: 'Tatiana', age: 33 }]

    storage.remove(2);

    console.log(storage.getAll()); // [{ id: 1, name: 'Egor', age: 33 }]

=================================================================================================================

14.1
 1. Инициализировать проект командой npm init, заполнить данные
 2. Установить локально typescript в проект и настроить в конфиге outdir, target, module, include, exclude
 3. Создать скрипт "build" для комплияции TS в JS
 4. Установить Eslint и Prettier с плагином Airbnb для TS
 5. Создать скрипты для запуска линтера и преттира с фиксами и без
 6. Установить Husky
 7. Создать пре-коммит хук для хаски в котором будет проверяться линтер и преттир
 8. Создать .gitignore, в который добавить node_modules и dist

Итак, последнее задание по JS/TS. Вложите в него все ваши знания и умения!)
Вам предстоит создать модель вашего заведения, используя объектно-ориентированный подход. 
Вы можете выбрать любой тип заведения (например, пиццерия, кофейня, ресторан), 
и вам нужно будет реализовать его функциональность, придерживаясь принципов ООП.
Вам самим решать что это за заведение, какие блюда подаются и так далее.
Ниже будет указан минимальный пример того, как можно реализовать. От вас же я жду полета фантазии и реализации:)

Итак, структура проекта в моем примере. Можете взять ее, и доделать, можете свою:

Класс Pizzeria
  Поля:
  name: string (Название заведения)
  address: string (Адрес)
  orders: Order[] (Список заказов)
  workingHours: string (Время работы)
  Методы:
  addOrder(order: Order): void (Добавление заказа)
  removeOrder(order: Order): void (Удаление заказа)
  getTotalRevenue(): number (Расчет общей выручки заведения)

Класс Order
  Поля:
  customerName: string (Имя заказчика)
  orderItems: Meal[] (Список позиций в заказе)
  totalPrice: number (Общая стоимость заказа)
  Методы:
  addItem(item: Meal): void (Добавление позиции в заказ)
  removeItem(item: Meal): void (Удаление позиции из заказа)
  calculateTotalPrice(): number (Расчет общей стоимости заказа)

Класс Meal
  Поля:
  name: string (Название блюда)
  price: number (Цена)
  Методы:
  abstract calculatePrice(): number (Метод для расчета стоимости блюда)

Enum'ы
  CupSizes (размеры стаканов)
  Prices (цены на различные размеры стаканов)
  
Класс Coffee, наследующийся от Meal
  Поля:
  volume: number (Объем стакана в мл)
  hasSugar: boolean (С сахаром ли)
  Методы:
  calculatePrice(): number (Метод для расчета стоимости кофе в зависимости от объема и наличия сахара)

Класс Pizza, наследующийся от Meal
  Поля:
  doughType: string (Тип теста)
  toppings: string[] (Начинки)
  size: string (Размер)
  Методы:
  calculatePrice(): number (Метод для расчета стоимости пиццы в зависимости от типа теста, начинки и размера)

Конечные блюда (например пицца Маргарита, либо кофе Латте) можно реализовывать 2 способами:
  1. Классами, например class Latte extends Coffee, где будут доп параметры только для Латте
  2. Через файл с рецептами, и конечный продукт будет создаваться просто из рецепта в конструткоре например пиццы:
    "pizzas": {
        "Margherita": {
            "doughType": "thin",
            "toppings": ["cheese", "tomato"],
            "size": "medium",
        },
      }
Способ выбирайте сами! Но я бы хотел видеть именно ваши любимые блюда и их рецепты! Даже если там пицца с ананасами)
Цены считаем в зависимости от вложенных продуктов в блюдо:)

=====================================================================================================================

16.1
https://flukeout.github.io/

16.2
https://topswagcode.com/xpath/

======================================================================================================================

17.1
- Установить WebdriverIO командой  npm init wdio@latest .
- Создать файл для теста с названием register.spec.ts
- Добавить во wdio.conf.ts путь к файлу с тестом в массив specs
Разработайте тест со следующими шагами:
1. Открыть страницу https://anatoly-karpovich.github.io/demo-login-form/ используя browser.url()
2. Кликнуть по кнопке Register методом . click()
3. Ввести валидные username/password (требования ниже) методом setValue()
4. Кликнуть Register
5. Завалидировать, верную нотификацию о регистрации методом .toHaveText()

17.2
Написать 2 тест сьюта:
1. Тесты на регистрацию
2. Тесты на логин

Сайт тот же, что и в Таск 1

Страница регистрации:
Username: обязательное, от 3 до 40 символов включительно, запрещены префиксные/постфиксные пробелы, как и имя состоящее из одних пробелов
Password: обязательное, от 8 до 20 символов включительно, необходима хотя бы одна буква в верхнем и нижнем регистрах, пароль из одних пробелов запрещен


Страница логина:

Username: обязательное

Password: обязательное


========================================================================================================================

18.1
Task 1.

Разработать тест со следующими шагами:

  - открыть https://the-internet.herokuapp.com/
  - перейти на страницу Dynamic Loading
  - Дождаться появления каждой ссылки на странице (их 2)
  - кликнуть по ссылке Example 1: Element on page that is hidden
  - дождаться появления кнопки start
  - кликнуть по кнопке start
  - дождаться появления текста "Hello World!" в теге h4 с помощью метода waitForElementWithText(), который вам надо разработать!:)

 Создать функцию waitForElementWithText(selector, text, timeout) для ожидания определенного текста (text) 
 у элемента с определенным селектором (selector) на протяжении определенного времени (timeout):
  - Использовать browser.waitUntil с комбинацией проверок (элемент виден и тест верный)
  - Добавить понятный timeoutMsg, с пояснением какие проверки не пройдены и селектором элемента

18.2
Task 2.
Разработать тест со следующими шагами:
 - Открыть url https://anatoly-karpovich.github.io/aqa-course-project/#
 - Войти в приложения используя учетные данные aqacourse@gmail.com / password при этом:
 - проверить исчезновение спиннера с помощью waitFor* методов
 - проверить действительно ли пользователь с логином AQA User вошел в систему
 - Прокликать каждый элемент бокового меню, убедится что после клика background-color элемента не красный

 Рекомендации по использованию:
 - метод $$ поиска по всем элементам
 - for .. of  для перебора коллекции элементов 
 - метод click() для клика по элементу в цикле
 - Проверить background-color можно двумя способами:
    1. По CSS стилю.  element.getCSSProperty('background-color)  https://webdriver.io/docs/api/element/getCSSProperty
    2. По отсутствию класса, отвечающего за добавление красного бэкграунда.  element.getAttribute('class') https://webdriver.io/docs/api/element/getAttribute

18.3
Разработать метод для выбора элемента в дропдауте "клавиатурой":
  selectDropdownValueWithKeys(dropdownSelector: string, optionsSelector: string, value: string)
  со следующими шагами:
    - кликнуть на дропдаун
    - дождаться появления элементов дропдауна на экране
    - Найти сколько раз надо нажать "вниз"
    - столько раз нажать стрелку ВНИЗ на клавиатуре, чтобы добраться до нужного элемента
    - нажать кнопку "Enter" на клавиатуре

Проверьте работу метода тут:
https://the-internet.herokuapp.com/
станица Dropdown


    Рекоммендации:
      - import { Key } from 'webdriverio'
      - Сверху импорт "ключей", в них есть и ArrowDown и Enter
      - browser.keys() для отправки "кликов" по клавиатуре


====================================================================================================================

Чтобы хром не дурил голову выбором Search Engine, замените во wdio.conf.ts раздел с capabilities на:
  capabilities: [
    {
      browserName: 'chrome',
      'goog:chromeOptions': {
        args: ['--disable-search-engine-choice-screen']
      }
    }
  ],


======================================================================================================================

19.1
Реализовать business и core слои во фреймворке для логин функциональности:
1. Написать Page Object класс для страницы Sign In:
  - email input
  - password input
  - login button
  - fillCredentials method
  - click on login button method

2. Написать PageService класс для SignIn, реализующий следующие методы:
  - login() (fillCredentials, click on login button, wait for spinner to hide)
  - loginAsAdmin(), который логинит используя учетные данные aqacourse@gmail.com / password

3. Сделать Core и Business классы для Home page

19.2
Разработать е2е тест со следующими шагами:
 - Открыть url https://anatoly-karpovich.github.io/aqa-course-project/#
 - Войти в приложения используя учетные данные aqacourse@gmail.com / password 
 - Создать продукт (модуль Products)
 - Верифицировать текст нотификации и закрыть кликнув на крестик
 - Открыть модалку Details для созданного продукта
 - Верифицировать данные в модалке
 - Закрыть модалку
 - Удалить продукт через ui

Рекоммендации:
 - Создайте Page Objects для модалок
 - Добавьте бизнес методы взаимодействия с модалками в ProductsService
 - Создайте метод(-ы) для работы с нотификациями (получить текст успешной нотификации, заверифицировать его с ожидаемым, закрыть нотификацию)
 
 Дополнительно: 
 Обратите внимание на схожесть модалок между собой,
   и, если найдете схожее, вынесите эти вещи на уровень выше, в класс от которого будут наследоваться конечные ПО модалок

19.3
В методах BasePage добавьте дополнительную возможность:
 - методы должны принимать не только строковый селектор, но и WebdriverIO.Element

Рекоммендации:
 - Для уточнения типа, напишите Type Guard


======================================================================================================================


20.1
Добавьте возможность валидации формы создания продукта
  - Добавить методы для валидации валидационных сообщений в AddNewProductService и AddNewProductPage
  - Метод должен проверять наличие валидационной ошибки, ее текст, а также то, что кнопка Save New Product недоступна

20.2
Написать валидационные автотесты по созданию продукта согласно требованиям.
Позитивные:
  - Напишите минимум 2 позитивных кейса (с минимумом и максимумов разрешенных символов в инпутах)
  - В afterHook необходимо добавить шаги по удалению созданного продукта (нажать на карзину в таблице, удалить через модалку)

Негативные:
  - Негативные валидации по очереди для всех инпутов
  - В каждом тесте необходимо проверить валидационное сообщение под проверяем инпутом
  - В каждом тесте проверить, что Save New Product кнопка задизейблена

20.3
Добавьте сокрытие секретных данных в вашем репортере:
  - Данные, вводимые в поле Password должны быть заменены на символы * в репортe

========================================================================================================================

21.1
- Написать класс signInApiClient:
  -- В конструкторе получить AxiosApiClient
  -- создать метод login(credentials: ICredentials) {
      //implement
      //использовать клиент полученный в конструкторе
    }

- Использовать его в Product smoke test в файле src/api/tests/products/smoke.test.ts


21.2
1. 
- Написать смоук тест сьют для эндпоинта продуктов с 5 тестами:
  -- Создать продукт
  -- Получить продукт по айди
  -- Получить все продукты
  -- Изменить продукт
  -- Удалить продукт

- Проверять статус код, IsSuccess, ErrorMessage
- Токен для запросов брать из респонса login запроса в before hook

2.
  Написать JSON схему для getAllProducts респонса (приходит массив продуктов)
  Использовать ее в тесте на получение всех продуктов

21.3
1.
  - Подключить библиотеку Axios (установить и саму библиотеку, и типизацию TS для нее (@types/axios))
  - Создать FetchApiClient класс для запросов используя fetch, а не Axios (https://axios-http.com/docs/api_intro):
  - FetchApiClient при вызове метода send должна принимать такой же интерфейс, как в лекции был для AxiosApiClient
  - При статусе 400-500 - выкидывать ошибку, поясняющую что случилось

2**. Выполняется строго ПОСЛЕ первого задания в Task 3
    Добавьте возможность работать с любой из обёрток (над fetch или axios):
    - Каждая из обёрток должна принимать и возвращать унифицированный интерфейс (IRequestOptions и IResponse соответственно)
    - IResponse должен содержать КАК МИНИМУМ статус, хедеры и тело ответа
    - Интерфейсы должны "подстраиваться" под типизацию тела запроса/ответа (используйте дженерики)
    - Создайте фабрику (factory pattern), из которой можно будет получать нужный класс с методом send() (нужную обертку)


========================================================================================================================

23.1

1. Создайте проект с WDIO + cucumber или склонируйте репозиторий с лекции
2. Создайте тест со своими данными для продукта и следующими шагами:
  Background:
    Given I open Sales Portal
    Then I should be on "Sign In" page
    When I enter "aqacourse@gmail.com" in "Email input" on "Sign In" page
    And I enter "password" in "Password input" on "Sign In" page
    And I click on "Login button" on "Sign In" page
    Then I should be on "Home" page
    And I should see "Logged User label" contains text "AQA " on "Home" page
  
  Scenario: Successfully created product
    When I click on "Products button" on "Home" page
    Then I should be on "Products List" page
    When I click on "Add New Product button" on "Products List" page
    Then I should be on "Add New Product" page
    When I enter "your name" in "Name input" on "Add New Product" page 
    And I select "your manufacturer" in "Manufacturer dropdown" on "Add New Product" page 
    And I enter "your price" in "Price input" on "Add New Product" page 
    And I enter "your amount" in "Amount input" on "Add New Product" page 
    And I enter "your notes" in "Notes input" on "Add New Product" page
    And I click on "Save New Product button" on "Add New Product" page
    Then I should be on "Products List" page
    And I should see notification contains text "Product was successfully created"

=====================================================================================================================

24.1
Используя код и подходы из последней лекции разработайте e2e сценарий со следующими шагами:
- Открыть портал
- Создать 2 продукта через API
- Залогиниться как админ
- Открыть страницу продуктов
- Завалидировать наличие продукта в таблице
- Открыть модалку деталей для первого созданного продукта
- Завалидировать данные в сравнении с созданными через апи данными
- Закрыть модалку деталей
- Открыть модалку деталей для второго созданного продукта
- Завалидировать данные в сравнении с созданными через апи данными
- Закрыть модалку деталей
- В афтер хуке удалить все созданные продукты

Рекоммендации:
- Передавайте данные между шагами сценария через this, либо через ProductStorage описанный в лекции
- Для создания нескольких продуктов измените степ I create product via API так, чтобы он принимал количество продуктов к созданию
- Для открытия модалок для разных продуктов сделайте метод, который, например, принимает "индекс" продукта, 
  и по индексу вытягивает продукт из ProductStorage или this. 
- Динамические селекторы для открытия модалок есть в Page Objects, если нету - создайте ;)

========================================================================================================================

25.1
Используя Playwright создать тест сьют с тестами со следующими шагами:
  Прекондишен:
    - Открыть Sales Portal
    - Залогиниться
    - Перейти на страницу Customers List
  Тесты:
    1. Проверить сортировки (asc/desc) для поля Email
    2. Проверить сортировки (asc/desc) для поля Name
    3. Проверить сортировки (asc/desc) для поля Country
    4. Проверить сортировки (asc/desc) для поля Created

  Рекоммендации:
    - Создайте метод в CustomersListService, который вытягивает все продукты из таблицы в массив объектов
    - Для сортировки по строчным значениям используйте localeCompare()
    - Для сортировки по датам - new Date(date1) - new Date(date2)


========================================================================================================================


26.1
1. 
Создайте тест со следующими шагами:
  - Создайте мок с кастомером, уже существующим в проекте
  - Залогиньтесь в проект
  - Перейдите на страницу Customers
  - Перейдите на страницу Add New Customer
  - Заполните поля валидными данными
  - Нажмите Save
  - Завалидируйте ошибку в нотификации с текстом `Customer with email '${customer.email}' already exists`

Рекоммендации:
  - Используйте класс Mock созданный в лекции


26.2
Homework 26

2.
Создайте тест сьют со следующими тестами:
  - Залогиньтесь в проект
  - Перейдите на страницу Customers
  - Перейдите на страницу Add New Customer
  - Ввести невалидные данные согласно требованиям в каждое поле
  - Проверить снэпшотами форму со всеми валидационными ошибками


Рекоммендации:
  - Используйте метод expect(form).toHaveScreenshot();
